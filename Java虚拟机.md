#   Java虚拟机

##  Java 运行时数据区

*   运行时数据区域     

    Java虚拟机在执行Java程序的过程中会把他管理的内存划分为若干个不同的数据区域。
      
*   程序计数器       

    程序计数器是一块较小的内存空间，它的作用可以看做是当前程序所执行的字节码的行号指示器。     
    在虚拟机的概念模型里，字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执      
    行的字节码指令，分支，循环，跳转，异常处理，线程恢复等基础功能都要依赖程序计数器来完成。
    Java虚拟机多线程是通过线程轮流切换并分配处理器执行时间的方式来实现的，在任何时刻一个    
    处理器只会执行一条线程中的指令（多核处理器既是一个核心处理一条），因此线程切换后能回到 
    正确的位置，每条线程都需要有一个程序计数器，每个线程中的程序计数器各自运行互不影响。程序    
    计数器是Java内存中唯一一个不会出现OOM的区域。
    
*   Java虚拟机栈

    Java虚拟机栈和程序计数器一样，也是线程私有，生命周期与线程相同。每个方法被执行的时候    
    都会同时创建一个栈帧用于存储局部变量表，操作栈，动态连接，方法出口等信息。每个方法被  
    调用直至执行完成的过程，就对应一个栈帧在虚拟机栈中从入栈到出栈的过程。     
    所谓的“栈”就是Java虚拟机栈，或者说Java虚拟机栈中的局部变量表部分。局部变量表存放了      
    编译时期可知的各种基本数据类型（byte，int......）,对象的引用和returnAddress类型。  
    局部变量表所有需要的内存空间，在编译时期完成分配，当进入一个方法时，这个方法需要在帧中     
    分配多大局部变量表空间是固定的，方法运行时期是不会改变的。       
    如果线程请求的栈深度大于虚拟机所允许的深度时，将抛出StackOverFlowError;如果虚拟机栈     
    可以动态扩展，当扩展时无法申请足够大内存会抛出OutOfMemoryError错误。
      
*   本地方法栈   
    
    和虚拟机栈所发挥的作用是一样的，只不过是为本地native方法服务。
    
*   Java堆       
    
    Java堆是一块被所有线程所共享的内存区域，在虚拟机启动时创建。此区域唯一的目的就是存放**对象实例**。   
    几乎所有的对象实例都在这里分配内存。所有的对象实例和数组都要在堆上分配。
    Java堆是垃圾收集器主要管理的区域，因此又被称作“GC”堆。
    
*   方法区 
    
    与Java堆一样，是各个线程共享的区域，它用于存储已经被虚拟机加载的类信息，常量，静态变量       
    即时编译后的代码等数据。        
    
*   运行时常量池      
    
    方法区的一部分，class文件中除了有类的版本，字段，方法，接口等信息以外，还有一项信息是常量池        
    用于存放编译时期生成的各种字面量和符号引用，这部分内容将在类加载后存放到方法区的运行时常量池。     

## 垃圾回收机制

* 对象访问
    
     Object object = new Object();  
     
     假设这句代码出现在方法体中，那“Object object”将反应到Java栈中本地变量表中，作为一个reference    
     类型出现。而“new Object()”这部分将反应到Java堆中，形成一块存储了Object类型所有实例数据值的结构化内存。    
     还有对象的类型数据，方法，接口，存储地址信息等存储在方法区中。
    
*   引用计数算法  
    
    给对象添加一个引用计数器，每当一个地方引用时计数器值+1，当引用失效时。计数器值就减1，任何时候计数器值都为零的时候  
    就是不可被再使用的时候。    
    **问题：** 难以解决对象之间的相互引用。eg：objectA.instance = objectB;objectB.instance = objectA;     
     此时计数器的值会一直不为0；
    
*   根搜索算法      
 
    通过一系列的名为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所引用的路径称为引用链，当一个对象到
    达GC Roots没有任何引用链时，则证明此对象不可用。  
      
*   Java语言中，可作为GC Roots的对象包括一下几种：   
    1. 虚拟机栈中的引用的对象
    2. 方法区中的类静态属性引用的对象。
    3. 方法区中的常量引用的对象。
    4. 本地方法栈中的JNI的引用的对象
*   引用
    1. 强引用：类似“Object object = new Object（）”这类的引用，只要引用还存在，垃圾回收机器就不会回收的引用。
    2. 软引用：用来描述一些还有用，但并非必须的对象。对于软引用关联着的对象，当系统将要发生内存溢出异常之前，将会        
    把这些对象列入回收范围之中并进行第二次回收。如果这次回收还没有足够的内存，就会报内存异常。
    3. 弱引用：用来描述非必须对象，强度比软引用再弱一点，被弱引用关联的对象只能生存到下一次垃圾回收发生之前。
    4. 虚引用：最弱的一种引用，为一个对象设置虚引用的唯一目的就是希望这个对象被垃圾回收时收到一个系统通知。   
    
*   总结  
    一个对象被回收，至少要被标注两次。     
      
###  垃圾收集算法
    
*   标记-清除算法：首先标记出所有需要回收的对象，再标记完成后统一回收掉所有被标记的对象。     
    **缺点：** 
    1. 效率比较低
    2. 标记清楚之后会产生大量不连续的碎片，空间碎片太多可能会导致，当程序在以后对的运行过程中需要分配较大对象时无法找到足够的      
    连续内存而不得不提前触发另一次垃圾收集动作。      
    
*   复制算法：将可用内存按容量划分为大小相当的两块，每次只使用其中的一块，当这一块用完了，就将还存活着的对象复制到另一块上，    
    然后再把已经使用过的一块清空。     
    **缺点:** 对象存活率比较高的时候，就要执行多次复制，效率将变低。         
    **适用于：** 新生代对象较多的内存
    
*   标记整理：标记过程和“标记-清除”算法一致，然后让所有存活的对象都像一端移动，然后直接清除掉端边界以外的内存。     
    **适用于：** 老年代对象较多的内存

*   分代收集： 根据对象的存活周期的不同将内存划分为几块。一般是将堆内存分为新生代和老年代，这样就可以根据年代的特点选择      
    合适的收集算法         
    **规则：** 在新生代中，每次垃圾收集时都会有大批的对象死去，只有少量存活，那就选择复制算法，只需要复出少量存活对象     
    复制成本就可以完成收集；而老年代中因为对象存活时间长，没有额外空间对它分配进行担保，就必须使用“标记整理”算法。
    
